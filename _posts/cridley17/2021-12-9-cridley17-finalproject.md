---
layout: post
author: cridley17
title: "Claire's Final Project and Reflection"
---
For my project I created a turtle game. The game requires the main game turtle controlled by the arrow keys, to traverse around obstacles, similar to a maze, and to collect five coins in a set amount of time for each level. The program can be viewed below:

<iframe src="https://trinket.io/embed/python/2341517b0d" width="100%" height="600" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>

	To begin my project I created a class for the main turtle the user controls and changed my screen background to black. The turtle would be shaped like a turtle, be colored pink, and have a starting point of (-190,50), which I envisioned would be the entrance to the maze. I called this turtle Terry for the game code. I will refer to this main turtle that the user controls by Terry for the rest of this reflection. I then created my user interface by defining functions that would move Terry forward ten and backward ten, and then turn Terry either left or right by ninety degrees. I then associated these functions with the arrow key clicks to move terry. 
	After I created the basic user interface to control my game turtle, I began work on the maze. Initially, I had envisioned a more complex maze and series of obstacles, but due to time constraints, I kept my maze simpler. I had also originally envisioned adding more obstacles for each level, but also due to time constraints did not have the time to figure out how to accomplish this with the rest of my program. For my maze, I created two modules. The first, called maze.py, created the class `MazeTurtle1` (note: this name reflects my original intent to have a new maze for each level). This class creates a turtle, hides it, changes the color to blue and the pen size to two for drawing. Then two functions follow: `draw_maze_outline` and `draw_maze_obstalce`. The first simply draws the outer boundary of the maze and game. The next draws rectangles to act as obstacles for Terry to traverse around, thus making a maze in the game. Maze may also not be the correct word to describe the series of obstacles, but it is the simplest and shortest way to describe them. 
	The next maze module I created was level_maze.py. This module imports the class `MazeTurtle` and then uses this turtle to a function called `level_one_maze` (note: this name reflects my original intent to have a new maze for each level). Level one maze uses the two functions of the maze turtle. It draws the outline first, then the turtle is moved to different places around the screen to draw the obstacles. 
	After creating the maze, I created a module that would write the basic text that would be needed on the screen for all the levels called screentext.py. This module created a new class called writing turtle that would be red. It had a function called `writetext` that took parameters for text, alignment, and font size. Then a function outside the class called `showtext` was created that used the `writetext` function to write the words on the bottom of the screen for “Level:”, “Score:”, and “Time:”. 
	Next, I worked on creating a basic timer that would run during gameplay in a module called timer.py. This module, in addition to importing turtle, also imports time. When I first worked on the timer, I only created one, the additional timers in this module were not created until later. This first timer function, originally called `timer_turtle` and then this name was changed to `timer_turtle1` to reflect the multiple timers across levels. This function originally looked like the code below
```
def timer_turtle():
  start = time.time()
  timeturtle = turtle.Turtle()
  timeturtle.color('red')
  while time.time() - start < 30:
    for seconds in range(30):
      screen.listen()
      timeturtle.hideturtle()
      timeturtle.speed(0)
      timeturtle.penup()
      timeturtle.goto(-5,-180)
      timeturtle.clear()
      timeturtle.write(int(time.time() - start), font=("courier", 10))
      screen.update()
  timeturtle.goto(-100,0)
  timeturtle.write("Time is Up!", font=("courier", 30))
```
The timer uses a while loop to count while the amount of seconds is less than 30. During this time a turtle contained in a for loop writes the seconds on the screen, and then when time is up the words “Time is Up!” are written on the screen to alert the player. In my main.py file, I also used a similar structure to ensure Terry only moved while the timer was active, shown below.
```
start = time.time()
while time.time() - start < 30:
  screen.onkey(go_left,"Left")
  screen.onkey(go_right, "Right")
  screen.onkey(go_forward, "Up")
  screen.onkey(go_backward, "Down")
  screen.listen()
  timer_turtle() #starts the timer
if time.time() - start > 30:
  screen.onkey(None,"Left") #changing the key clicks so Terry doesn't move
  screen.onkey(None, "Right")
  screen.onkey(None, "Up")
  screen.onkey(None, "Down")
```
By calling the screen key commands here, it created a safeguard to ensure the player couldn’t continue to play the game while the timer wasn’t active. 

After this first week of work, I had to readjust some of my goals to reflect the fact that I had done more work on my program than I originally expected. This became a common theme for the rest of my work on this project. I underestimated the time I would spend coding and ended up completing more work than my goals called for. I should have made my goals a little more ambitious to reflect the work ethic I adopted. 
	For the next week of work, the first goal I accomplished was creating the coins that would be drawn on the screen. To do this I created a new module called coins.py and in this module created a class called `CoinTurtle`. This called included a function called `draw_coin` that takes x and y coordinates as parameters. This function causes the turtle to move to certain coordinates and draw a yellow circle, creating the coins to collect for the game. 
	Next, I created three functions in main.py that would establish all three of my levels. In these functions, I called the `level_one_maze` function to draw the maze at the start of the level, and then added the while loop I created on week one that both starts the timer and ensures that Terry can only move while the timer is active. 
	My next obstacle was to figure out how to restart my levels if the timer reached the max amount, and eventually if the score was not high enough. To do this, I added if/else statements to my functions for my levels. In the statements, if the timer goes above the set amount of time for each level, like thirty seconds for level one, Terry moves back to the starting point and the key click commands are removed in this time to ensure Terry can’t move until the timer begins again.
	One game function that was integral to playing was not allowing Terry to move across the maze obstacles that were drawn on screen and not allowing Terry outside the maze outline. Initially, I stopped Terry at the maze borders by adding to the functions that move him forward and backward. For example, the forward function looked like this:
```
def go_forward(): #moves Terry forward, checks intersections with maze and coins
  terry.forward(10)
  if terry.ycor()>190: 
    terry.goto(-190,50)
  if terry.ycor()<-188:
    terry.goto(-190,50)
  if terry.xcor()<-180:
    terry.goto(-190,50)
  if terry.xcor()>198:
    terry.goto(-190,50)
```
This worked well for the maze outline. Whenever Terry stepped out of bounds, he would return to the starting position. However, I still needed a way to ensure that he couldn’t move through the obstacles. I tried to use an if statement that checked the distance from Terry and the turtle that draws the maze, but this did not work because the drawing maze turtle moves around the screen and would only be at one specific location, not all the locations of the obstacles. 
	From this point, I then tried using lists to store coordinates. I stored Terry’s x position and y position into variables and then stored the (x,y) position into a list called `current_pos`. I then tried to do the same thing with the maze turtle, but I found that all of the coordinates that an obstacle covered wouldn’t be included. I then decided I would create a maze coordinate list and add in the coordinates myself. This probably is not the best way to do this, but it was a solution to my problem. In order to write the `maze_coord` list, I printed the list for Terry’s position, and moved him over the obstacles to see where they were located. I then typed in these coordinates into a list in a module called maze_list.py. With both of these lists, I used a for loop to check if Terry’s position was in the maze coordinates list. The code looked like this:
```
x = int(round(terry.xcor())) #storing terry's location
y = int(round(terry.ycor()))
current_pos = [(x,y)]
#print (current_pos)
for elements in current_pos: #loop checking terry's intersection with maze obstacles
    if elements not in maze_coord:
      continue
    else:
      terry.goto(-190,50)
      terry.setheading(0)
```
If Terry’s x and y matched any coordinates in the maze list, he would return to the start. I then used the if statements from above for the outline and this code with the lists in a function called `check_maze_obstacle_intersection` that I called in my functions that move Terry forward and backward. This code was successful in moving Terry to the start point if he intersected with any of the coordinates that were in the maze coordinates list. 
	For the next week, my first major accomplishment creating the function that draws the coins on the screen. I decided to use a list like I used in the maze intersection before to store the coordinates of the coins that were drawn. Due to the fact I wanted the coins’ locations to change, I used random integers for my coins’ x and y. I also only used random integers that were multiples of tens because Terry moves forward ten, and therefore would only hit coordinates that were multiples of ten, thus making a future check for intersection possible. I used a for loop to generate the random x and y and append the `coin_pos` list. I neseted another for loop within to check the coin’s intersection with the maze. In theory, if coordinates are not in the maze coordinates list, a coin will be drawn. However, I have found that coins will still be drawn inside the maze obstacles, and this is an issue that I have tried to remedy, but cannot seem to fix. 
The next issue I needed to solve was increasing the score if Terry went over, or “collected” a coin. I spent a lot of time working on this function a tried a couple of methods before it worked the way I wanted it to. I originally started this `coin_intersect` function like the maze intersection function by using an if statement that checked Terry’s distance from the coin turtle. When this did not work, I decided the best course of action would be to use lists again, just like the maze intersection. Luckily, I was storing the coin position in the `make_level_coins` function, so this was feasible. Just as I did before, I stored Terry’s x and y into variables and then placed those variables into a list. I then used the same structure of a for loop with an if statement to check if the elements in Terry’s position list were in the coin position list. If they were not in the list, the loop would continue, if they were, I increased a variable for score by one. I then decided the best way to store and access my score would be a dictionary instead of a variable. I then created a dictionary called score to store this value and added one to the key value with coin intersection. Then, in my if statement I had the turtle that writes on the screen write the key in the dictionary. 
	After this, so the player would be able to visually see whether they had collected a coin, I added a new function in coins.py in my `CoinTurtle` class. I called this new function `hit_coin`. This function takes x and y as parameters and at that location will draw a red circle. I then called this function in my `coin_intersect` function, within the if/else statement. The hit coin turtle uses Terry’s location to draw the red circle, when Terry is in the same place as a coin. So now, the player can see a coin has been collected, and also can see the score increase. 
	Next, I created two more timers in my timer.py module that would run for 20 seconds and 15 seconds so they would be the timers for levels two and three respectively. After this, I created my while loop that would put everything together and run the game. In my while loop, I use if statements to iterate through all of my levels. For all three levels, I use a combination of time and score to make sure the level moves on when the player has collected the right amount of coins. At the beginning of each level, a turtle writes what level you are on, then the function `make_level_coins` is called and then the function to create the level itself is called. The if statements also help to ensure the levels reset if time is up, and the coins clear and re-draw themselves. 
	Originally, I had created a level counter using a dictionary, similar to the score count. However, when I played the game, and a level re-started, the level count would still increase by one. So, if I had restarted level one, the level count at the bottom of the screen would read as level two. I changed this by using a turtle in my if statements nested in my while loop that would write the level number, instead of storing the value in a dictionary or variable. 
	Another aspect I added was directions that would show before the game starts. To do this, I changed my score dictionary to this ` score = {'score': -1}`. Then, I created an if statement in my main game while loop that would have a turtle write the directions on the screen while the key of the score was -1. At the end of this if statement one was added to the key so the game would start with a score of zero, and also the directions would not repeat every time level one restarted if the player ran out of time. 
	After this week of work, I still had to add a few more components to my program so that it would satisfy all of the project requirements. For my win screen, I imported an image into trinket that shows a trophy and says you win. This image is shown after time has run out on the third level and the player has reached fifteen points. I used this image as the shape of a turtle due to its size, and also when I tried to set it as the screen, it would flicker and not show the image constantly. To have the game repeat, I used `time.sleep(10)` to put the win screen on for a set time, and then I set the score dictionary to zero and clear the win screen. This causes the game to go back to the beginning. Ideally, I would have liked to use a keyboard command, or clicks to do this so the player could control when the game would restart, but I was unable to accomplish this before the project deadline. 
	Another component I needed to add was constantly available help dialogue. To accomplish this I created three separate functions that had turtles that would write a set of instructions for each level on the screen and then disappear. Then, in my level functions, I assigned the “w” key to call the help text function. 
	One aspect of the game function that was not running smoothly at this point was the score increment. The score would still add one, even if the coin had been “collected.” Essentially, this meant a player could cheat the game by moving over only one coin over and over. To fix this I added the code below to my `coin_intersect` function.
```
if elements in hitcoord: 
      score['score']-=1
      write_text.clear()
      write_text.goto(183,-180)
      write_text.write(score['score'], font = ('Courier',10))
```
This checks Terry’s position against the list of coordinates the collected coins are in. If they are in the same spot, the score decreases by one, which offsets the increase by moving over a coin. The score cancels itself out and stays the same. However, this only works on the coin that was most recently collected. A player can collect points on a coin that has already been collected if it is not the most recent one. This is a flaw in the game that I have been working on with no real solution. I have tried multiple ways of rewriting the code, but this is, unfortunately, the only way this concept semi-works. 
	I also had issues with adding the external data file. I could not think of a component of my game that I could use an external file for. Initially, I tried to store my maze coordinates from the maze coordinate list into a .txt file, but when I imported the file, I was having trouble converting the values to integers rather than strings. I tried storing the x values in one file and the y in another. I could store x and y in separate lists and change them to integers, but I could not figure out how to pair them together as coordinates. Due to this, I decided I would just put my instructions into a .txt file. In a module called game_instructions_txt.py I open the file, split the line of text by word and then store the words into a list. I then used the list index to get the words I needed for each line of text that would show on the screen. There is probably a better way to do this, and a better external file to use, but I was at a loss for any other ideas at this point. 
	One major issue my code still has is that coins are still drawing themselves within the maze obstacles, and they cannot be collected for points. I have tried many different versions of for loops and if statements to make this work. In these iterations, either the program took too long to draw to the coins, the coins still drew over the maze, or a combination of both. I decided to just have more coins drawn on the screen than the player needs points to ensure that the player can still advance to the next level if the coins aren’t in collectible positions. 
	Another issue my code has is redundancy, particularly between my while loop that runs the game, and the functions that create each level. Both of these aspects of my code contain many of the same lines. However, I am not sure whether I should delete the code in the functions or the while loop. If I had extra time, I would delete some of the redundancy so I could be able to test and see how the program is affected when I run it. 
	Overall, I spent a great amount of time working with this program. Unfortunately, it still needs work with the coin aspect to make it function more smoothly. I found that I spent more time working on this project than I had initially expected. This can be seen in the fact that I always accomplished more than what my goals outlined. I often found myself working with the program in lulls of time where I was bored or had other free time to spare. This was time I generally hadn’t spent on schoolwork previously this semester, which is why I did not take this time into account when setting goals. I was highly motivated to work on this project and solve any problems that I encountered in my code, which is why I used any spare free time to work. I was pleasantly surprised by my motivation for this project and it especially helped when I was feeling frustrated. 
	An additional aspect I noticed while working on this program was that once I figured one thing out, like how to use lists to check the intersection of the main turtle with the maze, I was able to use the concept in multiple places. This was extremely helpful for many parts of my game functionality. Using the same concepts again, especially knowing that it worked effectively in one aspect of my program already, helped to save me some time and frustration while I was working. Additionally, if there was a time I was feeling frustrated because I could not figure out how to make the program function like I wanted to, I would resort to using a concept I already had, and then the program would run like I wanted it to. I learned that if a particular concept or way of writing a piece of code works, I should use it where I can. 
I also found that making small adjustments to my program and then testing it was very helpful. After every small edit, I would write in my code, I would run it to not only ensure that the game functioned in the correct way, but to also make sure I didn’t have any syntactical errors or any errors that would prevent the code from running. By running my program frequently, I was able to debug at that moment and save myself frustration at the end of a longer work session if my code was not running and I needed to find and fix multiple errors. I would also run my code using the `print` function frequently. For example, when figuring out coin and maze intersections with Terry, I would print out Terry’s position list. This list was also very helpful in creating the maze coordinates list. I would move Terry to the places where I didn’t want him to go, and then would add the printed coordinates to my maze list. 
 One way I worked through my frustration on this project when something was not working how I wanted to, was that I would take a break and come back to the code. Generally, I took shorter breaks, no longer than twenty minutes, and I made sure I saved the code and closed trinket so I couldn’t work on my break. I used that time to clear my head and to try and not think about the project. Usually, after I took a break I was able to make great progress and work through the issue that made me frustrated. Coming back to the program with a clear head allowed me to see aspects I had not considered before. 
Overall, this project made me realize that I was more comfortable using Python and the concepts I learned earlier in the semester that I had previously thought or realized. When I read the requirements for the project, I initially was very intimidated because I did not think I was going to be able to use all the concepts I needed to, or that I would remember how to use them properly. Also, even if I did not completely remember a concept, the textbook was an extremely helpful resource and was able to give me ideas to use in my program. I referred to RuneStone at several points in this process to review concepts like dictionaries and lists to ensure that I was using them in my code properly, and to remember different ways I could implement them in my code. I also realized that I was able to synthesize many concepts and all the practice from the textbook problems had paid off. 
